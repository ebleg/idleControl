%% IDLE SPEED CONTROL EXERCISE
% -------------------------------------------------------------------------
% Michael Chadwick, Twan van der Sijs & Emiel Legrand
% ETH Zurich - Institute for Dynamics and Systems Constrol
% Engine Systems (November 2017)
% -------------------------------------------------------------------------
% Master file
% -------------------------------------------------------------------------

%% PREPARE WORKSPACE
clear;
clc;
close all;

addpath(genpath('.'));

%% TOGGLE OPTIONS
identify_params = 0; % general switch
linearize_model = 1;

identify_throttle_toggle = 1;
identify_engine_toggle = 1;
identify_manifold_toggle = 1;
identify_manifold2_toggle = 0;
identify_inertia_toggle = 0;

plot_validation_toggle = 1;
convert_data_toggle = 0;

validation_toggle = 0;

%% LOAD PARAMETERS
fprintf('------ MAIN -------\n \n');
fprintf('$ Loading static parameters ...');
run params;

%% create filename variables
dataFile_id_q = 'quasistatic_0007_extracted.mat';
dataFile_id_dyn = 'dynamic_0028_extracted.mat';
dataFile_val = 'dynamic_0005_extracted.mat';

fprintf(' Done\n');

%% CODE
%% Data conversion
if convert_data_toggle
    fprintf('$ Converting data ...');
    convert_data('dynamic_0006_extracted.mat');
    fprintf(' Done\n');
end

%% Parameter identification
if identify_params
    
    if identify_throttle_toggle
        fprintf('\n$ Identify throttle parameters ...');
        pars = parinit(dataFile_id_q, pars);
        [pars.id.alpha_0, pars.id.alpha_1] = ...
            identify_throttle(dataFile_id_q, ...
            pars, ...
            plot_validation_toggle);
        fprintf(' Done\n');
    end
    
    if identify_engine_toggle
        fprintf('$ Identify engine parameters ...');
        pars = parinit(dataFile_id_q, pars);
        [pars.id.gamma_0, pars.id.gamma_1] = ...
            identify_engine(dataFile_id_q, ...
            pars, ...
            plot_validation_toggle);
        fprintf(' Done\n');
    end
    
    if identify_manifold2_toggle
        fprintf('$ Identify intake manifold volume (model 2) ...\n');
        [pars.id.V_m] = ...
            identify_md2(dataFile_id_dyn, ...
            pars, ...
            plot_validation_toggle);
    end
    
    if identify_manifold_toggle
        fprintf('$ Identify intake manifold volume (model 1) ...\n');
        pars = parinit(dataFile_id_dyn, pars);
        [pars.id.V_m] = ...
            identify_intakemfd(dataFile_id_dyn, ...
            pars, ...
            plot_validation_toggle);
        fprintf('... Done\n');
    end
    
    if identify_inertia_toggle
        fprintf('$ Identify torque and inertia ...');
        pars = parinit(dataFile_id_dyn, pars);
        [pars.id.eta_0, ...
            pars.id.eta_1, ...
            pars.id.beta_0, ...
            pars.id.THETA_e] = ...
            identify_ti(dataFile_id_dyn, ...
            pars, ...
            plot_validation_toggle);
        fprintf(' Done\n');
    end
else
    %% LOAD IDENTIFIED PARAMETERS
    load('pars.mat');
end



%% Validate model
if validation_toggle
    fprintf('$ Validating model ... ');
    pars = parinit(dataFile_val, pars);
    validation(dataFile_val, pars)
    fprintf('Done\n');
end

%% Normalize and linearize the model

if linearize_model
    fprintf('$ Linearize system without delays ...');
    
    [system.ss.nodelay.A,system.ss.nodelay.B,...
        system.ss.nodelay.C,system.ss.nodelay.D] = ...
        linmod('model_norm_nodelay.slx',[1,1],[1,1,1,1]);
    
    system.tf.lin_nodelay = tf(ss([system.ss.nodelay.A, ...
                            system.ss.nodelay.B, ...
                            system.ss.nodelay.C, ...
                            system.ss.nodelay.D]));
    fprintf('Done\n');
    
    fprintf('$ Approximate delays seperately and add them to the transfer functions ...')
    system.tf.delay1 = pade(pars.nom.delay1,4);
    system.tf.delay2 = pade(pars.nom.delay2,4);
    
    
    
    %% use iconnect functionality
    % create ic
    u1 = icsignal(1); u2 = icsignal(1); u3 = icsignal(1); u4 = icsignal(1);
    y1 = icsignal(1); y2 = icsignal(1); y3 = icsignal(1);
    
    Q = iconnect;
    Q.input = [u1 ; u2 ; u3 ; u4];
    Q.output = [y1 ; y2 ; y3];
    
    Q.Equation{1} = equate(u3 , system.tf.delay1 * y2);
    Q.Equation{2} = equate(u4 , system.tf.delay2 * y3);
    Q.Equation{3} = equate(y1 , system.tf.lin_nodelay(1,1) * u1 + ...
                    system.tf.lin_nodelay(1,2) * u2 + ...
                    system.tf.lin_nodelay(1,3) * u3 + ...
                    system.tf.lin_nodelay(1,4) * u4);
    
    system.tf.lin = tf(Q.System);
    system.ss.lin = ssdata(syste
    
    fprintf('Done\n');
else
    load('system.mat');
end




fprintf('\n------ END --------\n');
